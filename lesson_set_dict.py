# Tasks for lesson on the topic of "set() | dict()"

# new_set = set()
# new_set2 = {1, 5, 2}
# new_dict = {}
# new_dict2 = {"key": "value", "key2": "value2"}

#new_dict2.keys() віведе всі ключі зі словника
#new_dict2.values() виведе всі значення зі словника
#new_dict2.items()

# Beginner level

#1
# Створіть словник зі списками добрих справ на сьогодні і на завтра. Надрукуйте із словника добрі справи, які плануєш зробити сьогодні і взавтра.
def task1():
    to_do = {
        "today": ["read", "clear", "dog"],
        "tomorrow": ["read", "call my mom"]
    }

    print("To do for today:")
    for item in to_do["today"]:
        print("-", item)

    print("To do for tomorrow:")
    for item in to_do["tomorrow"]:
        print("-", item) 

# task1()

#2
# Припустимо, що у нас є словник, в якому ключі є ідентифікаторами, а значення – іменами користувачів. Напишіть програму, яка виводить вітальне повідомлення користувачу на основі його ідентифікатора. Якщо ідентифікатор відсутній у словнику, виводиться вітання для усіх користувачів.

# Вхідні дані:
# 232
# 550
# 190
# 500

# Вихідні дані:
# Hi, Alice!
# Hi, Bob!
# Hi, Jack!
# Hi, to all!

def task2():
    users = {
        0: "Alice",
        1: "Bob",
        2: "Jack"
    }
    user_id = int(input("Your id: "))

    if user_id in users:
        print(f"Hello, {users[user_id]}")
    else:
        print("Hello to all!")

# task2()

#3
# Напишіть програму для сортування за зростанням (за алфавітом) словника за ключами. Словник зберігає пари ключ-значення у вигляді «назва фільму: рік релізу». Інформація виводиться як у вихідних даних: сортування має бути проведено за назвами фільмів.

# Вихідні дані:
# ('Avengers: Endgame', 2019) ('Guardians of the Galaxy', 2014) ('Iron Man', 2008) ('Thor', 2011)

def task3():
    films = {
        'Guardians of the Galaxy': 2014,
        'Iron Man': 2008,
        'Avengers: Endgame': 2019,
        'Thor': 2011
        }
            
    sorted_films = dict(sorted(films.items()))

    for name in sorted_films.items():
        print(f"{name}")

# task3()

#4
# Надрукуйте елементи словника, де ключі - це числа від '1' до 'n' (обидва числа включно), а значення - квадрати ключів. 'n' – ціле число, яке вводить користувач.

def task4():
    n = int(input("n; "))

    # squares = {} # dict()
    # for i in range(1, n+1):
    #     # dict[key] = value
    #     squares[i] = i ** 2
    # print(squares)

#analog:
    squares = {i: i ** 2  for i in range(1, n+1)}
    print(squares)

# task4()

#5
# Створіть словник, в кому ключі – назви днів тижня, а значення - цілі числа, що позначають порядковий номер дня тижня від 0 до 6. Надрукуйте назву дня за введеним порядковим номером дня. Якщо введений номер виходить за межі, програма жодних повідомлень не друкує і не повідомляє про помилку.

def task5():
    weeks = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    days = [i for i in range(7)]

            # week_dict = {}
            # for day in range(7):
            #     week_dict[weeks[day]] = days[day]

            #analog: через zip(keys, values) ВАЖЛИВО к-сть ключів і значень має співпадати
    week_dict = dict(zip(weeks, days))

    n = int(input("Enter number weeksday: "))
    for day, number in week_dict.items():
        if number == n:
            print(day)
            break

# task5()

#6
# Напишіть програму для створення словника із введеного рядка символів для підрахунку кількості символів.

# Вхідні дані:
# Lorem ipsum dolor sit amet

# Вихідні дані:
# {'L': 1, 'o': 3, 'r': 2, 'e': 2, 'm': 3, ' ': 4, 'i': 2, 'p': 1, 's': 2, 'u': 1, 'd': 1, 'l': 1, 't': 2, 'a': 1}

def task6():
# Исходный текст, который будем анализировать
    text = "Lorem ipsum dolor sit amet"

    # Преобразуем строку в список символов
    # Каждый символ строки, включая пробелы, становится отдельным элементом списка
    text = list(text)

    # Создаём словарь для подсчёта символов
    # Для каждого символа 'i' в списке text:
    #   1. Считаем, сколько раз этот символ встречается во всём списке с помощью text.count(i)
    #   2. Сохраняем результат в словарь letters, где ключ — символ, а значение — количество повторов
    # Обратите внимание: если символ повторяется, его значение в словаре перезаписывается,
    # в итоге остаётся общее количество повторов.
    letters = {i: text.count(i) for i in text}

    # Выводим словарь с подсчитанными символами
    # Пример вывода:
    # {'L': 1, 'o': 3, 'r': 2, 'e': 2, 'm': 3, ' ': 4, 'i': 2, 'p': 1, 's': 2, 'u': 1, 'd': 1, 'l': 1, 't': 2, 'a': 1}
    print(letters)

# task6()

#7
#  Напишіть програму, яка приймає рядок символів, і обчислює кількість букв і цифр.

# Вхідні дані:
# Project Gutenberg offers over 59,000 free eBooks

# Вихідні дані
# LETTERS 36
# DIGITS 5

def task7():
    text = "Project Gutenberg offers over 59,000 free eBooks"

    digit_count = 0
    alpha_count = 0

    for char in text:
        if char.isdigit():
            digit_count += 1
        elif char.isalpha():
            alpha_count += 1

    result = {
        "LETTERS": alpha_count,
        "DIGITS": digit_count
    }

    for key, value in result.items():
        print(key, value)

# task7()


# Middle level

#8
# Напишіть програму для видалення дублікатів зі списку цілих чисел.


#9
# Дано список словників. Кожен словники має 2 пари елементів: ключ 'name' і значення імені студента, ключ 'points' і значення - список балів з різних дисциплін (цілі двоцифрові числа). Надрукуйте найменші значення балів, отримані кожним студентом, в один рядок з пропуском.

#10
# Дано два списки чисел. Порахуйте, скільки унікальних цифр міститься в обох з них.
def task10_1():
    numbers1 = [1, 5, 3, 8, 0, 1]
    numbers2 = [23, 9, 0, 1, 5]

    result = len(set(numbers1 + numbers2))
    print(result)

# task10_1()
#-------------------------------------------
def task10_2():
    # Створюємо дві множини (set). У множині всі елементи унікальні, тому другий '1' зникне автоматично.
    numbers1 = {1, 5, 3, 8, 0, 1}
    numbers2 = {23, 9, 0, 1, 5}

    # ----- ОБ’ЄДНАННЯ МНОЖИН -----
    # Об’єднання (union) — створює нову множину, яка містить усі унікальні елементи з обох множин.
    print(numbers1.union(numbers2))   # метод union()
    print(numbers1 | numbers2)        # те саме, але короткий запис через оператор |

    # ----- РІЗНИЦЯ МНОЖИН -----
    # A - B (difference) — створює множину, яка містить лише ті елементи з A, яких немає у B.
    print(numbers1.difference(numbers2))   # метод difference()
    print(numbers1 - numbers2)             # короткий запис через оператор -

    # ----- СИМЕТРИЧНА РІЗНИЦЯ -----
    # Симетрична різниця (symmetric_difference) — створює множину, яка містить елементи,
    # що є лише в одній з множин (НЕ спільні).
    print(numbers1.symmetric_difference(numbers2))  # метод symmetric_difference()
    print(numbers1 ^ numbers2)                      # короткий запис через оператор ^

    # ----- ПЕРЕТИН МНОЖИН -----
    # Перетин (intersection) — це спільні елементи, які є в обох множинах.
    # УВАГА: метод intersection_update() змінює numbers1, залишаючи в ній тільки спільні елементи!
    print(numbers1.intersection_update(numbers2))   # змінює numbers1, тому результат — None
    print(numbers1 & numbers2)                      # оператор &, створює нову множину зі спільними елементами

#task10_2()

#11
# Дано три словники, в яких ключами є малі букви латинського алфавіту, а значеннями - цілі числа. Ключі у всіх словниках – різні, їх є по 3 в кожному словнику. Об’єднайте всі три словники в один і виведіть його вміст. Підказка. скористайтеся оператором **, що використовується для об’єднання довільної кількості словників.

#12
#  Створіть словник, який відображає ідентифікатори акцій на біржі. Ключами словника є ідентифікатори акцій, а значеннями - дійсні числа - ціни акцій. Надрукуйте ціни акцій та ідентифікатори у порядку зростання ціни.

# Вихідні дані:
# 10.75 FB
# 37.2 HPQ
# 45.23 ACME
# 205.55 IBM
# 612.78 AAPL

# print(stocks.values())
# print(sorted(list(stocks.values())))
# for v in stocks.values():
#         print(v)

# # print(stocks.items())
# # print(list(stocks.items()))

# print(sorted(stocks.items(), key=get_value))

def task12():
    # Створюємо словник 'stocks', де:
    #   ключ (key) — це назва компанії (рядок),
    #   значення (value) — це ціна акції (число з плаваючою крапкою).
    stocks = {
        "IBM": 205.55,
        "FB": 10.75,
        "ACME": 45.23,
        "AAPL": 612.78,
        "HPQ": 37.2
    }

    # Оголошуємо функцію get_value(), яка приймає один аргумент — 'item'
    # 'item' тут буде кортежем (key, value), наприклад ("IBM", 205.55)
    # Функція повертає елемент item[1] — тобто значення (ціну акції)
    def get_value(item):
        return item[1]

    # Проходимо по словнику, відсортованому за значеннями (тобто за цінами)
    # 1. stocks.items() — повертає пари (ключ, значення)
    # 2. sorted(..., key=get_value) — сортує ці пари за значенням, використовуючи функцію get_value()
    # 3. for key, value in ... — розпаковує пари у змінні key та value
    for key, value in sorted(stocks.items(), key=get_value):
        # Виводимо ціну (value) і назву компанії (key)
        print(value, key)

# task12()

#13
#  В рядку записаний текст. Словом вважається послідовність непробільних символів, які йдуть підряд, слова розділені одним або більшим числом пропуском або символами кінця рядка. Для кожного слова з цього тексту підрахуйте, скільки разів воно зустрічалося в цьому тексті раніше.

# Вхідні дані:
# var list set tuple list tuple tuple dict var

# Вихідні дані:
# 0 0 0 0 1 1 2 0 1


# Hard level

# 14
# Напишіть програму, яка зможе підрахувати слова у введеному рядку, розділені пропуском і вивести отриману статистику: для кожного унікального слова обчислити число його повторень (без урахування регістру), слова не повинні повторюватися, порядок слів довільний.

# Вхідні дані:
# a bb acD bb abc ac BCD a

# Вихідні дані:
# a 2
# bb 2
# acd 1
# abc 1
# ac 1
# bcd 1

def task14():
    # Початковий рядок тексту
    # 1. .lower() — переводить усі символи в нижній регістр (щоб "A" і "a" вважалися однаковими)
    # 2. .split() — розділяє рядок на слова за пробілами і створює список
    text = "a bb acD bb abc ac BCD a".lower().split()
    # Після цього text буде виглядати так:
    # ['a', 'bb', 'acd', 'bb', 'abc', 'ac', 'bcd', 'a']

    # (Закоментовано) — можна створити множину, щоб побачити унікальні слова
    # text_set = set(text)
    # print(text_set)

    # Створюємо порожній словник, у якому будемо зберігати підрахунок слів
    result = {}

    # Проходимо по кожному слову у списку text
    for word in text:
        # Використовуємо метод словника get():
        #   result.get(word, 0) — повертає поточне значення для ключа word, 
        #   або 0, якщо такого ключа ще немає
        # Потім додаємо 1, щоб збільшити лічильник для цього слова
        result[word] = result.get(word, 0) + 1

# Проходимо по всіх парах (ключ, значення) у словнику result
    for key, value in result.items():
    # Виводимо слово (key) і кількість його повторень (value)
        print(key, value)

#task14()

#15
#  Дано два списки чисел. Знайдіть всі числа, що зустрічаються як в першому, так і другому списках, і надрукуйте їх у порядку зростання.

# Вхідні дані:

# 2 5 8 11 10 9
# 11 3 7 6 8 5
# Вихідні дані:

# 5 8 11

#16

# Напишіть програму, яка вміє шифрувати і розшифровувати використовуючи шифр підстановки. Програма приймає на вхід два рядки однакової довжини, у першому рядку записані символи початкового алфавіту, у другому рядку - символи кінцевого алфавіту (шифр підстановки), після чого йде рядок, який потрібно зашифрувати переданим шифром підстановки, і ще один рядок, який потрібно розшифрувати. Нехай, наприклад, на вхід програми передано:
# abcd
# *d%#
# abacabadaba
# #*%*d*%
# Це означає, що символ a вхідного повідомлення замінюється на символ * в шифрі, b замінюється на d, c - на % і d - на #. Потрібно зашифрувати рядок abacabadaba і розшифрувати рядок #*%*d*% за допомогою цього шифру. Отримуємо наступні рядки, які і передаємо на виведення програми:
# *d*%*d*#*d*
# dacabac

# Вхідні дані:
# abcd
# 1234
# ababcdcd
# 44332211

# Вихідні дані:
# 12123434
# ddccbbaaz